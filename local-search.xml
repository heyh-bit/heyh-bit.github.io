<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lambda Expressions</title>
    <link href="/2025/06/25/Lambda-Expressions/"/>
    <url>/2025/06/25/Lambda-Expressions/</url>
    
    <content type="html"><![CDATA[<p><strong>函数式接口（Functional Interface）</strong> 是 Java 8 引入的核心特性之一，为 Lambda 表达式和方法引用提供了支持。</p><p>Lambda 表达式是 JDK 8 引入最重要特性之一，它允许以简洁的匿名函数形式编写代码，减少冗余代码并提高可读性。</p><span id="more"></span><blockquote><p>Note：该文档要求 JDK 版本为 8+ 以上；</p></blockquote><p><strong>函数式接口（Functional Interface）</strong> 是指<strong>有且仅有一个抽象方法</strong>的接口（但可以有多个默认方法或静态方法）。</p><p><strong>Lambda 表达式</strong>，本质上是函数式接口的一个具体实现的简洁写法。</p><p><strong>方法引用</strong>，本质上是 Lambda 表达式的一个简洁写法。</p><p>Lambda 表达式是匿名内部类的简写形式，学习 Lambda 表达式能快速简洁实现匿名内部类，通过以下两个代码可看出 Lambda 代码的简洁性。</p><ul><li>函数式接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;;<br>consumer.accept(<span class="hljs-string">&quot;hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>函数式接口 + Lambda 表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);<br>consumer.accept(<span class="hljs-string">&quot;hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>函数式接口 + Lambda 表达式 + 方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = System.out::println;<br>consumer.accept(<span class="hljs-string">&quot;hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><p>函数式接口、Lambda表达式、方法引用（了解）、Stream API三者的核心关系及学习顺序：</p><pre><code class=" mermaid">graph LR    A[1. 函数式接口] --&gt;|提供目标类型| B[2. Lambda表达式]    B --&gt;|标准实现方式| C[3. 方法引用]    C --&gt;|语法糖优化| B    B --&gt;|实现行为参数化| D[4. Stream API]    C --&gt;|简化操作| D    D --&gt;|依赖操作类型| A    D --&gt;|处理数据| E[(集合/数组/I/O)]        style A fill:#FFCCFF,stroke:#333,stroke-width:2px    style B fill:#CCCCFF,stroke:#333,stroke-width:2px    style C fill:#CCFFCC,stroke:#333,stroke-width:2px    style D fill:#FFCC99,stroke:#333,stroke-width:2px    style E fill:#E0E0E0,stroke:#333,stroke-width:2px</code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口（Functional Interface）：有且仅有一个抽象方法的接口，但可有多个非抽象方法的接口（JDK8 支持 default、static 默认方法实现）；</p><p>函数式接口表示形式，<code>有 @FunctionalInterface 注解</code> 和 <code>无 @FunctionalInterface 注解</code> 两种形式；</p><ul><li>使用 @FunctionalInterface 注解，仅有一个抽象方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无 @FunctionalInterface 注解，仅有一个抽象方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 @FunctionalInterface 注解，仅有一个抽象方法，多个实现方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br>   <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无 @FunctionalInterface 注解，仅有一个抽象方法，多个实现方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ul><li>无参，无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无参，有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参（单个参数），无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Object Param1)</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Object Param1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参（单个参数），有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">(Object Param1)</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">(Object Param1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参（多个参数），无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Object... param)</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Object... param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参（多个参数），有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口形式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">(Object... param)</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口形式二</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    Object <span class="hljs-title function_">method</span><span class="hljs-params">(Object... param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>常用的函数式接口类型分为四个：<code>Consumer&lt;T&gt;</code>、<code>Supplier&lt;T&gt;</code>、<code>Function&lt;T, R&gt;</code>、<code>Predicate&lt;T&gt;</code>。</p><p>函数式接口常用方法、功能描述及应用场景：</p><table><thead><tr><th align="left">接口</th><th align="left">方法签名</th><th align="left">功能描述</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>Consumer&lt;T&gt;</code></strong></td><td align="left"><code>void accept(T t)</code></td><td align="left">消费参数无返回值</td><td align="left">遍历操作、IO 写入</td></tr><tr><td align="left"><strong><code>Supplier&lt;T&gt;</code></strong></td><td align="left"><code>T get()</code></td><td align="left">无参数提供返回值</td><td align="left">工厂模式、延迟初始化</td></tr><tr><td align="left"><strong><code>Function&lt;T,R&gt;</code></strong></td><td align="left"><code>R apply(T t)</code></td><td align="left">参数转换后返回新值</td><td align="left">数据转换、链式处理</td></tr><tr><td align="left"><strong><code>Predicate&lt;T&gt;</code></strong></td><td align="left"><code>boolean test(T t)</code></td><td align="left">参数条件判断</td><td align="left">数据过滤、条件校验</td></tr><tr><td align="left"><strong><code>UnaryOperator&lt;T&gt;</code></strong></td><td align="left"><code>T apply(T t)</code></td><td align="left">一元运算（同类型转换）</td><td align="left">对象修改、数学运算</td></tr><tr><td align="left"><strong><code>BinaryOperator&lt;T&gt;</code></strong></td><td align="left"><code>T apply(T t1, T t2)</code></td><td align="left">二元运算（同类型合并）</td><td align="left">集合归约、数值计算</td></tr></tbody></table><hr><h4 id="消费型接口：Consumer"><a href="#消费型接口：Consumer" class="headerlink" title="消费型接口：Consumer&lt;T&gt;"></a>消费型接口：Consumer&lt;T&gt;</h4><p>Consumer 接口是 Java 8 引入的函数式接口（位于 java.util.function 包中），用于表示接受一个输入参数且不返回结果的操作。它通常用于需要消费对象（如修改对象、打印、发送数据等）但不产生返回值的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 对输入参数 t 执行特定操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br><br>    <span class="hljs-comment">// 链式组合两个 Consumer，按顺序执行操作</span><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="供给型接口：Supplier"><a href="#供给型接口：Supplier" class="headerlink" title="供给型接口：Supplier&lt;T&gt;"></a>供给型接口：Supplier&lt;T&gt;</h4><p>Supplier&lt;T&gt; 是 java.util.function 包中的一个函数式接口（Functional Interface），它代表一个提供者，或者说是一个无参数的工厂方法。它的核心作用是不接收任何参数，但能返回一个指定类型（T）的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 无参生成值，不接收输入参数，返回指定类型 T 的值</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数型接口：Function"><a href="#函数型接口：Function" class="headerlink" title="函数型接口：Function&lt;T, R&gt;"></a>函数型接口：Function&lt;T, R&gt;</h4><p>Function&lt;T, R&gt; 是 Java 8 引入的核心函数式接口，位于 java.util.function 包中。它代表一个接受一个输入参数并返回结果的函数，常用于数据转换和流水线处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    <br>    <span class="hljs-comment">//核心方法：接收T类型参数，返回R类型结果</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>; <br><br>    <span class="hljs-comment">// 组合函数：先执行当前函数，再执行after函数</span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="hljs-title function_">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> V, ? extends T&gt; before)</span> &#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br><br>    <span class="hljs-comment">// 组合函数：先执行before函数，再执行当前函数</span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br><br>    <span class="hljs-comment">// 返回一个始终返回输入参数的函数</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="hljs-title function_">identity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="断言型接口：Predicate"><a href="#断言型接口：Predicate" class="headerlink" title="断言型接口：Predicate&lt;T&gt;"></a>断言型接口：Predicate&lt;T&gt;</h4><p>Predicate&lt;T&gt; 是 Java 8 引入的函数式接口（位于 java.util.function 包中），用于表示一个布尔值函数（接受参数并返回 true&#x2F;false）。它常用于数据过滤、条件验证等场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 核心方法：对输入参数 t 进行条件判断</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T var1)</span>;<br><br>    <span class="hljs-comment">// 逻辑与：组合两个 Predicate</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; var1)</span> &#123;<br>        Objects.requireNonNull(var1);<br>        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.test(var2) &amp;&amp; var1.test(var2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 逻辑非：取反</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (var1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.test(var1);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 逻辑或：组合两个 Predicate</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; var1)</span> &#123;<br>        Objects.requireNonNull(var1);<br>        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.test(var2) || var1.test(var2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断两个对象是否相等（使用 Objects.equals()）</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object var0)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == var0 ? Objects::isNull : (var1) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> var0.equals(var1);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h4><ul><li>accept(T t) 用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// accept 方法</span><br>Consumer&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;;<br>res.accept(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 输出: Hello</span><br></code></pre></td></tr></table></figure><ul><li>andThen(Consumer&lt;? super T&gt; after) 链式组合用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; toUpper = s -&gt; System.out.println(s.toUpperCase());<br>Consumer&lt;String&gt; addExclamation = s -&gt; System.out.println(s + <span class="hljs-string">&quot;!&quot;</span>);<br><br><span class="hljs-comment">// 组合: 先转大写，再添加感叹号</span><br><span class="hljs-comment">// 先执行 toUpper 然后执行 addExclamation</span><br>Consumer&lt;String&gt; combined = toUpper.andThen(addExclamation);<br>combined.accept(<span class="hljs-string">&quot;hello&quot;</span>); <br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// HELLO</span><br><span class="hljs-comment">// hello!</span><br></code></pre></td></tr></table></figure><h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h4><ul><li>获取字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;String&gt; greetingSupplier = () -&gt; <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> greetingSupplier.get(); <span class="hljs-comment">// 调用 get() 获取值 -&gt; &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><ul><li>方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引用静态方法</span><br>Supplier&lt;Double&gt; randomSupplier = Math::random; <span class="hljs-comment">// 相当于 () -&gt; Math.random()</span><br><span class="hljs-type">double</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> randomSupplier.get();<br><br><span class="hljs-comment">// 引用无参构造器 (创建新对象)</span><br>Supplier&lt;ArrayList&lt;String&gt;&gt; listSupplier = ArrayList::<span class="hljs-keyword">new</span>; <span class="hljs-comment">// 相当于 () -&gt; new ArrayList&lt;&gt;()</span><br>ArrayList&lt;String&gt; newList = listSupplier.get();<br></code></pre></td></tr></table></figure><ul><li>匿名内部类 (传统方式，Lambda 之前常用)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Integer&gt; magicNumberSupplier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 著名的“宇宙终极答案”</span><br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> magicNumberSupplier.get(); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h4 id="Function"><a href="#Function" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h4><ul><li>apply(T t) 用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行函数逻辑</span><br>Function&lt;String, Integer&gt; strToInt = s -&gt; Integer.parseInt(s);<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> strToInt.apply(<span class="hljs-string">&quot;42&quot;</span>); <span class="hljs-comment">// 返回 42</span><br></code></pre></td></tr></table></figure><ul><li>andThen(Function after) 用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 组合函数（当前函数 → after函数）</span><br>Function&lt;String, Integer&gt; strToInt = Integer::parseInt;<br>Function&lt;Integer, Integer&gt; square = n -&gt; n * n;<br><br>Function&lt;String, Integer&gt; pipeline = strToInt.andThen(square);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pipeline.apply(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">// 返回 16</span><br></code></pre></td></tr></table></figure><ul><li>compose(Function before) 用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 组合函数（before函数 → 当前函数）</span><br>Function&lt;Integer, Integer&gt; square = n -&gt; n * n;<br>Function&lt;Integer, String&gt; intToStr = Object::toString;<br><br>Function&lt;Integer, String&gt; pipeline = intToStr.compose(square);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pipeline.apply(<span class="hljs-number">4</span>); <span class="hljs-comment">// 返回 &quot;16&quot;</span><br></code></pre></td></tr></table></figure><ul><li>identity() 用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回输入参数本身</span><br>Function&lt;String, String&gt; sameString = Function.identity();<br>System.out.println(sameString.apply(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h4><ul><li>基础用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;Integer&gt; isEven = num -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>System.out.println(isEven.test(<span class="hljs-number">4</span>));  <span class="hljs-comment">// true</span><br>System.out.println(isEven.test(<span class="hljs-number">5</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>组合条件（and&#x2F;or）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; isLong = s -&gt; s.length() &gt; <span class="hljs-number">5</span>;<br>Predicate&lt;String&gt; containsA = s -&gt; s.contains(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-comment">// 组合：长度 &gt; 5 且包含 &quot;A&quot;</span><br>Predicate&lt;String&gt; combined = isLong.and(containsA);<br><br>System.out.println(combined.test(<span class="hljs-string">&quot;HelloA&quot;</span>));  <span class="hljs-comment">// true（长度=6且含&quot;A&quot;）</span><br>System.out.println(combined.test(<span class="hljs-string">&quot;Hi&quot;</span>));      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>取反（negate）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;Integer&gt; isPositive = n -&gt; n &gt; <span class="hljs-number">0</span>;<br>Predicate&lt;Integer&gt; isNonPositive = isPositive.negate();<br><br>System.out.println(isNonPositive.test(-<span class="hljs-number">1</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>静态方法 isEqual</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; isHello = Predicate.isEqual(<span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(isHello.test(<span class="hljs-string">&quot;Hello&quot;</span>));  <span class="hljs-comment">// true</span><br>System.out.println(isHello.test(<span class="hljs-string">&quot;Hi&quot;</span>));     <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h4><ul><li>修改对象状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>&#125;<br><br>Consumer&lt;User&gt; setNameConsumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(User user)</span> &#123;<br>        user.setName(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>setNameConsumer.accept(user);<br>System.out.println(user.name); <span class="hljs-comment">// 输出: Alice</span><br></code></pre></td></tr></table></figure><ul><li>集合遍历（forEach）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一</span><br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>names.forEach(name -&gt; System.out.println(<span class="hljs-string">&quot;[LOG] Processed: &quot;</span> + name));<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">//Alice [LOG] Processed: Alice</span><br><span class="hljs-comment">//Bob [LOG] Processed: Bob</span><br><span class="hljs-comment">//Charlie [LOG] Processed: Charlie</span><br><br><span class="hljs-comment">// 方式二</span><br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br><span class="hljs-comment">// 组合操作：打印 + 记录日志</span><br>Consumer&lt;String&gt; log = s -&gt; System.out.println(<span class="hljs-string">&quot;[LOG] Processed: &quot;</span> + s);<br>names.forEach(print.andThen(log));<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Alice [LOG] Processed: Alice</span><br><span class="hljs-comment">// Bob [LOG] Processed: Bob</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><ul><li>批量处理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>users.forEach(u -&gt; u.setName(<span class="hljs-string">&quot;Admin&quot;</span>)); <span class="hljs-comment">// 批量设置用户名</span><br></code></pre></td></tr></table></figure><ul><li>结合 <code>Optional</code> 避免空指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; optional = Optional.of(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// public void ifPresent(Consumer&lt;? super T&gt; var1)</span><br>optional.ifPresent(s -&gt; System.out.println(s.length())); <span class="hljs-comment">// 输出: 5</span><br></code></pre></td></tr></table></figure><ul><li>资源管理（模拟 <code>try-with-resources</code> 模式）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;AutoCloseable&gt; useResource = resource -&gt; &#123;<br>    <span class="hljs-keyword">try</span> (resource) &#123;<br>        <span class="hljs-comment">// 使用资源（例如操作文件/数据库）</span><br>        System.out.println(<span class="hljs-string">&quot;Resource used&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;;<br><br>useResource.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.txt&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>工厂模式应用（动态创建对象并初始化）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;Map&lt;String, String&gt;&gt; initConfig = config -&gt; &#123;<br>    config.put(<span class="hljs-string">&quot;timeout&quot;</span>, <span class="hljs-string">&quot;30s&quot;</span>);<br>    config.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>&#125;;<br><br>Map&lt;String, String&gt; config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>initConfig.accept(config); <span class="hljs-comment">// 初始化配置对象</span><br></code></pre></td></tr></table></figure><h4 id="Supplier-1"><a href="#Supplier-1" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h4><p><code>Supplier</code> 的进阶用法聚焦于：<strong>延迟计算</strong>（优化性能）、<strong>动态行为</strong>（运行时决定逻辑）、<strong>模式实现</strong>（工厂、缓存、回退等）<strong>代码解耦</strong>（分离创建与使用）。</p><ul><li>延迟初始化 (Lazy Initialization)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Supplier 延迟高成本对象的创建, 直到真正需要时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyInitializer</span> &#123;<br>    <span class="hljs-keyword">private</span> Supplier&lt;ExpensiveObject&gt; expensiveObject = () -&gt; createAndCache();<br><br>    <span class="hljs-keyword">private</span> ExpensiveObject <span class="hljs-title function_">createAndCache</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ExpensiveObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpensiveObject</span>(); <span class="hljs-comment">// 高成本操作</span><br>        expensiveObject = () -&gt; obj; <span class="hljs-comment">// 替换为直接返回缓存</span><br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> expensiveObject.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结合 <code>Optional</code> 避免空指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 orElaseGet(Supplier) 安全获取值</span><br>Optional&lt;String&gt; optionalValue = fetchNullableValue();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> optionalValue.orElseGet(() -&gt; generateDefaultValue());<br></code></pre></td></tr></table></figure><ul><li>动态配置加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据条件动态提供不同实现</span><br>Supplier&lt;DataSource&gt; dataSourceSupplier = () -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (isProduction()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductionDataSource</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDataSource</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-type">DataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> dataSourceSupplier.get();<br></code></pre></td></tr></table></figure><ul><li>缓存结果 (Memoization)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过包装 Supplier 实现结果缓存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Supplier&lt;T&gt; <span class="hljs-title function_">memoize</span><span class="hljs-params">(Supplier&lt;T&gt; delegate)</span> &#123;<br>    AtomicReference&lt;T&gt; cached = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <span class="hljs-keyword">return</span> () -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (cached.get() == <span class="hljs-literal">null</span>) &#123;<br>            cached.set(delegate.get());<br>        &#125;<br>        <span class="hljs-keyword">return</span> cached.get();<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>Supplier&lt;BigInteger&gt; factorial = memoize(() -&gt; calculateFactorial(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><ul><li>日志消息的延迟求值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 避免不必要的字符串拼接 (当日志级别未启用时)</span><br><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(Example.Class);<br>Supplier&lt;String&gt; expensiveLogMessage = () -&gt; <span class="hljs-string">&quot;Data: &quot;</span> + fetchData();<br><br><span class="hljs-keyword">if</span> (logger.isLoggable(Level.FINE)) &#123;<br>    logger.fine(expensiveLogMessage.get());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>生成序列&#x2F;唯一ID</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建状态保持的生成器</span><br>Supplier&lt;Long&gt; idGenerator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>&#125;;<br><br>System.out.println(idGenerator.get()); <span class="hljs-comment">// 0</span><br>System.out.println(idGenerator.get()); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ul><li>依赖注入与工厂模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解耦对象创建逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;PaymentGateway&gt; gatewaySupplier;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PaymentService</span><span class="hljs-params">(Supplier&lt;PaymentGateway&gt; gatewaySupplier)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gatewaySupplier = gatewaySupplier;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">PaymentGateway</span> <span class="hljs-variable">gateway</span> <span class="hljs-operator">=</span> gatewaySupplier.get();<br>        gateway.charge(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用时注入实现</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentService</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">StripeGateway</span>());<br></code></pre></td></tr></table></figure><ul><li>组合多个 Supplier</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现链式回退逻辑</span><br>Supplier&lt;String&gt; primarySource = () -&gt; fetchFromDB();<br>Supplier&lt;String&gt; fallbackSource = () -&gt; fetchFromCache();<br><br>Supplier&lt;String&gt; combined = () -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> primarySource.get();<br>    <span class="hljs-keyword">return</span> (result != <span class="hljs-literal">null</span>) ? result : fallbackSource.get();<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Function-1"><a href="#Function-1" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h4><ul><li>基本函数组合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// andThen() 和 compose() 方法</span><br>Function&lt;Integer, Integer&gt; multiplyBy2 = x -&gt; x * <span class="hljs-number">2</span>;<br>Function&lt;Integer, String&gt; intToString = x -&gt; <span class="hljs-string">&quot;Result: &quot;</span> + x;<br><br><span class="hljs-comment">// 先执行 multiplyBy2，再执行 intToString</span><br>Function&lt;Integer, String&gt; pipeline = multiplyBy2.andThen(intToString);<br><br><span class="hljs-comment">// 先执行 add5，再执行 multiplyBy2</span><br>Function&lt;Integer, Integer&gt; composed = multiplyBy2.compose(x -&gt; x + <span class="hljs-number">5</span>);<br><br>System.out.println(pipeline.apply(<span class="hljs-number">3</span>));      <span class="hljs-comment">// 输出: Result: 6</span><br>System.out.println(composed.apply(<span class="hljs-number">3</span>));      <span class="hljs-comment">// 输出: 16 (3+5=8, 8*2=16)</span><br></code></pre></td></tr></table></figure><ul><li>多个函数串联</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等价于: Function&lt;String, String&gt; trim = String::trim;</span><br>Function&lt;String, String&gt; trim = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.trim();<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 等价于: Function&lt;String, String&gt; toUpper = String::toUpperCase;</span><br>Function&lt;String, String&gt; toUpper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.toUpperCase();<br>    &#125;<br>&#125;;<br><br><br>Function&lt;String, String&gt; addPrefix = s -&gt; <span class="hljs-string">&quot;hello world!!! &quot;</span> + s;<br><br>Function&lt;String, String&gt; fullProcessor = trim<br>    .andThen(toUpper)<br>    .andThen(addPrefix);<br><br>System.out.println(fullProcessor.apply(<span class="hljs-string">&quot;  I&#x27;m coming! &quot;</span>)); <span class="hljs-comment">// 输出: hello world!!! I&#x27;m coming!</span><br></code></pre></td></tr></table></figure><ul><li>条件函数管道</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; createPipeline = threshold -&gt; <br>    n -&gt; (n &gt; threshold) ? n * <span class="hljs-number">2</span> : n / <span class="hljs-number">2</span>;<br><br>Function&lt;Integer, Integer&gt; highValueProcessor = createPipeline.apply(<span class="hljs-number">100</span>);<br>Function&lt;Integer, Integer&gt; lowValueProcessor = createPipeline.apply(<span class="hljs-number">10</span>);<br><br>System.out.println(highValueProcessor.apply(<span class="hljs-number">150</span>)); <span class="hljs-comment">// 300 (150&gt;100 → 150*2)</span><br>System.out.println(lowValueProcessor.apply(<span class="hljs-number">5</span>));    <span class="hljs-comment">// 2 (5&lt;10 → 5/2=2.5→整数2)</span><br></code></pre></td></tr></table></figure><ul><li>函数柯里化（Currying）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 柯里化: 把接受多个参数的函数变成接受一个单一参数(最初函数的第一个参数)的函数, 并且返回接受余下的参数且返回结果的新函数的技术;</span><br><span class="hljs-comment">// 三参数函数</span><br>Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; curry = <br>    a -&gt; b -&gt; c -&gt; (a + b) * c;<br><br><span class="hljs-comment">// 逐步应用参数</span><br>Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add5 = curry.apply(<span class="hljs-number">5</span>);<br>Function&lt;Integer, Integer&gt; add5And10 = add5.apply(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> add5And10.apply(<span class="hljs-number">3</span>); <span class="hljs-comment">// (5+10)*3 = 45</span><br><br>System.out.println(result);<br></code></pre></td></tr></table></figure><ul><li>部分应用（Partial Application）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 固定函数的部分参数</span><br>BiFunction&lt;Integer, Integer, Integer&gt; multiply = (a, b) -&gt; a * b;<br><br><span class="hljs-comment">// 固定第二个参数为10</span><br>Function&lt;Integer, Integer&gt; multiplyBy10 = a -&gt; multiply.apply(a, <span class="hljs-number">10</span>);<br><br>System.out.println(multiplyBy10.apply(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 70</span><br></code></pre></td></tr></table></figure><ul><li>函数记忆化（Memoization）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Integer&gt; <span class="hljs-title function_">memoize</span><span class="hljs-params">(Function&lt;Integer, Integer&gt; function)</span> &#123;<br>    Map&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">return</span> input -&gt; cache.computeIfAbsent(input, function);<br>&#125;<br><br>Function&lt;Integer, Integer&gt; expensiveCalc = n -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Calculating for &quot;</span> + n);<br>    <span class="hljs-comment">// 模拟耗时计算</span><br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;&#125;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;;<br><br>Function&lt;Integer, Integer&gt; memoized = memoize(expensiveCalc);<br><br>System.out.println(memoized.apply(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 第一次计算（慢）</span><br>System.out.println(memoized.apply(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 从缓存获取（快）</span><br></code></pre></td></tr></table></figure><ul><li>异常处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThrowingFunction</span>&lt;T, R, E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&gt; &#123;<br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> E;<br>&#125;<br><br><span class="hljs-keyword">static</span> &lt;T, R&gt; Function&lt;T, R&gt; <span class="hljs-title function_">unchecked</span><span class="hljs-params">(ThrowingFunction&lt;T, R, Exception&gt; f)</span> &#123;<br>    <span class="hljs-keyword">return</span> t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> f.apply(t);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;;<br>&#125;<br><br>Function&lt;String, Integer&gt; safeParseInt = unchecked(Integer::parseInt);<br>System.out.println(safeParseInt.apply(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><ul><li>Optional结合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;String, Optional&lt;Integer&gt;&gt; safeParse = s -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.of(Integer.parseInt(s));<br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-keyword">return</span> Optional.empty();<br>    &#125;<br>&#125;;<br><br>Optional&lt;Integer&gt; result = safeParse.apply(<span class="hljs-string">&quot;42&quot;</span>)<br>    .map(n -&gt; n * <span class="hljs-number">2</span>)<br>    .filter(n -&gt; n &gt; <span class="hljs-number">50</span>);<br><br>result.ifPresentOrElse(<br>    System.out::println,<br>    () -&gt; System.out.println(<span class="hljs-string">&quot;Invalid or too small&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>函数工厂模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Operation</span> &#123; ADD, SUBTRACT, MULTIPLY, DIVIDE &#125;<br><br>Function&lt;Operation, BiFunction&lt;Double, Double, Double&gt;&gt; operationFactory = op -&gt; <br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> ADD -&gt; (a, b) -&gt; a + b;<br>        <span class="hljs-keyword">case</span> SUBTRACT -&gt; (a, b) -&gt; a - b;<br>        <span class="hljs-keyword">case</span> MULTIPLY -&gt; (a, b) -&gt; a * b;<br>        <span class="hljs-keyword">case</span> DIVIDE -&gt; (a, b) -&gt; b != <span class="hljs-number">0</span> ? a / b : Double.NaN;<br>    &#125;;<br><br>BiFunction&lt;Double, Double, Double&gt; multiplier = operationFactory.apply(Operation.MULTIPLY);<br>System.out.println(multiplier.apply(<span class="hljs-number">5.0</span>, <span class="hljs-number">4.0</span>)); <span class="hljs-comment">// 20.0</span><br></code></pre></td></tr></table></figure><ul><li>高级Stream处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态处理管道</span><br>List&lt;Function&lt;String, String&gt;&gt; processors = Arrays.asList(<br>    String::toUpperCase,<br>    s -&gt; s.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>),<br>    s -&gt; <span class="hljs-string">&quot;ID-&quot;</span> + s<br>);<br><br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-string">&quot;Jane Smith&quot;</span>, <span class="hljs-string">&quot;Bob Johnson&quot;</span>);<br><br>List&lt;String&gt; processed = names.stream()<br>    .map(processor -&gt; processors.stream()<br>        .reduce(Function.identity(), Function::andThen)<br>        .apply(processor))<br>    .toList();<br><br><span class="hljs-comment">// 输出: [ID-JOHN_DOE, ID-JANE_SMITH, ID-BOB_JOHNSON]</span><br>System.out.println(processed);<br></code></pre></td></tr></table></figure><ul><li>函数装饰器模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Function&lt;Integer, Integer&gt;, Function&lt;Integer, Integer&gt;&gt; timerDecorator = f -&gt; n -&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> f.apply(n);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br>    System.out.println(<span class="hljs-string">&quot;Execution took: &quot;</span> + duration + <span class="hljs-string">&quot;ms&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>Function&lt;Integer, Integer&gt; factorial = n -&gt; <br>    (n &lt;= <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : n * factorial.apply(n - <span class="hljs-number">1</span>);<br><br>Function&lt;Integer, Integer&gt; timedFactorial = timerDecorator.apply(factorial);<br><br>System.out.println(timedFactorial.apply(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出结果和执行时间</span><br></code></pre></td></tr></table></figure><h4 id="Predicate-1"><a href="#Predicate-1" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h4><ul><li>组合（Composition）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 and(), or(), negate() 组合</span><br>Predicate&lt;String&gt; isLong = s -&gt; s.length() &gt; <span class="hljs-number">5</span>;<br>Predicate&lt;String&gt; containsA = s -&gt; s.contains(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-comment">// 组合：长度 &gt; 5 且包含 &quot;A&quot;</span><br>Predicate&lt;String&gt; combined = isLong.and(containsA);<br><br><span class="hljs-comment">// 组合：长度 &gt; 5 或不包含 &quot;A&quot;</span><br>Predicate&lt;String&gt; combined2 = isLong.or(containsA.negate());<br></code></pre></td></tr></table></figure><ul><li>链式动态构建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态构建复杂谓词链</span><br>Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (condition1) predicate = predicate.and(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (condition2) predicate = predicate.or(x -&gt; x &lt; -<span class="hljs-number">10</span>);<br><br>list.stream().filter(predicate)... <span class="hljs-comment">// 动态过滤</span><br></code></pre></td></tr></table></figure><ul><li>工厂模式生成谓词</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 封装谓词创建逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PredicateFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Predicate&lt;String&gt; <span class="hljs-title function_">hasLength</span><span class="hljs-params">(<span class="hljs-type">int</span> min)</span> &#123;<br>        <span class="hljs-keyword">return</span> s -&gt; s.length() &gt;= min;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Predicate&lt;String&gt; <span class="hljs-title function_">contains</span><span class="hljs-params">(String substr)</span> &#123;<br>        <span class="hljs-keyword">return</span> s -&gt; s.contains(substr);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>list.stream()<br>    .filter(PredicateFactory.hasLength(<span class="hljs-number">5</span>).and(PredicateFactory.contains(<span class="hljs-string">&quot;Java&quot;</span>)))<br></code></pre></td></tr></table></figure><ul><li>处理空安全（Null-Safe）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 防御空指针异常</span><br>Predicate&lt;String&gt; safeContains = s -&gt; s != <span class="hljs-literal">null</span> &amp;&amp; s.contains(<span class="hljs-string">&quot;safe&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>类型转换与适配器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与其他函数式接口互操作</span><br><span class="hljs-comment">// BiPredicate 转 Predicate</span><br>BiPredicate&lt;String, Integer&gt; biPredicate = (s, i) -&gt; s.length() &gt; i;<br>Predicate&lt;String&gt; adapted = s -&gt; biPredicate.test(s, <span class="hljs-number">5</span>); <span class="hljs-comment">// 固定参数</span><br><br><span class="hljs-comment">// 兼容旧式代码</span><br>Predicate&lt;String&gt; legacyAdapter = s -&gt; LegacyUtils.isValid(s);<br></code></pre></td></tr></table></figure><ul><li>集合操作优化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Person&gt; people = Arrays.newList;<br>Predicate&lt;Person&gt; isAdult = p -&gt; p.getAge() &gt;= <span class="hljs-number">18</span>;<br>Predicate&lt;Person&gt; isDeveloper = p -&gt; <span class="hljs-string">&quot;Developer&quot;</span>.equals(p.getJob());<br><br><span class="hljs-comment">// 分区：满足条件 vs 不满足条件</span><br>Map&lt;Boolean, List&lt;Person&gt;&gt; partitioned = people.stream()<br>    .collect(Collectors.partitioningBy(isAdult.and(isDeveloper)));<br></code></pre></td></tr></table></figure><ul><li>状态保持谓词（谨慎使用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有状态的谓词（需注意线程安全）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>        count++;<br>        <span class="hljs-keyword">return</span> s.length() &gt; <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> count; &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-type">CounterPredicate</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterPredicate</span>();<br>list.stream().filter(counter).count();<br>System.out.println(<span class="hljs-string">&quot;Checked &quot;</span> + counter.getCount() + <span class="hljs-string">&quot; elements&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>嵌套对象处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 深度属性检查</span><br>Predicate&lt;Order&gt; hasHighValue = order -&gt; <br>    order.getCustomer() != <span class="hljs-literal">null</span> &amp;&amp;<br>    order.getCustomer().getAddress() != <span class="hljs-literal">null</span> &amp;&amp;<br>    order.getTotal() &gt; <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// 使用 Optional 简化</span><br>Predicate&lt;Order&gt; safer = order -&gt;<br>    Optional.ofNullable(order)<br>        .map(Order::getCustomer)<br>        .map(Customer::getAddress)<br>        .isPresent() &amp;&amp; order.getTotal() &gt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><ul><li>性能优化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 昂贵操作缓存结果</span><br>Map&lt;String, Boolean&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Predicate&lt;String&gt; expensiveCheck = s -&gt; <br>    cache.computeIfAbsent(s, k -&gt; doHeavyComputation(k));<br></code></pre></td></tr></table></figure><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p> Lambda 表达式本质上是函数式接口的一个具体实现的简洁写法。</p><p>Lambda 表达式是匿名内部类的简写形式，学习 Lambda 表达式能快速简洁实现匿名内部类。</p><p>Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。</p><p>Lambda 表达式它是函数式编程思想的一个重要体现，不用关注是什么对象，而是更关注对数据进行了什么操作。</p><p><strong>核心语法：(parameters) -&gt; { expression or statements }</strong></p><ul><li>(parameters)：参数列表（可省略类型声明，若只有一个参数可省略括号 ()），参数列表可不写参数类型；</li><li>-&gt;：Lambda 操作符（箭头符号）</li><li>{ }：方法体（单行表达式可省略 {} 和 return；多行语句需保留 {} 和显式 return）</li></ul><h3 id="基本格式-1"><a href="#基本格式-1" class="headerlink" title="基本格式"></a>基本格式</h3><p>Lambda 表达式涵盖了无参、有参（单个参数、多个参数）、无返回值、有返回值六种场景。</p><p>参数列表有两种形式：（Type param）和（param）两种形式，前面一种不省略参数类型，后面一种省略参数类型（推荐使用省略）；</p><p>若参数为单个且 Lambda 体为一条语句时，小括号和大括号可去除。</p><ul><li>无参，无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>无参，有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123; <span class="hljs-keyword">return</span> obj; &#125;;<br></code></pre></td></tr></table></figure><ul><li>有参（单个参数），无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形式一</span><br>(Type Param1) -&gt; &#123;&#125;;<br><span class="hljs-comment">// 形式二</span><br>(Param1) -&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>有参（单个参数），有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形式一</span><br>(Type Param1) -&gt; &#123; <span class="hljs-keyword">return</span> obj; &#125;;<br><span class="hljs-comment">// 形式二</span><br>(Param1) -&gt; &#123; <span class="hljs-keyword">return</span> obj; &#125;;<br></code></pre></td></tr></table></figure><ul><li>有参（多个参数），无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形式一</span><br>(Type ... params) -&gt; &#123;&#125;;<br><span class="hljs-comment">// 形式二</span><br>(param1, ... ,paramN) -&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>有参（多个参数）, 有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形式一</span><br>(Type ... params) -&gt; &#123; <span class="hljs-keyword">return</span> obj; &#125;;<br><span class="hljs-comment">// 形式二</span><br>(param1, ... ,paramN) -&gt; &#123; <span class="hljs-keyword">return</span> obj; &#125;;<br></code></pre></td></tr></table></figure><h3 id="接口类型-1"><a href="#接口类型-1" class="headerlink" title="接口类型"></a>接口类型</h3><h4 id="无参无返回"><a href="#无参无返回" class="headerlink" title="无参无返回"></a>无参无返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; 一条语句<br></code></pre></td></tr></table></figure><h4 id="无参有返回"><a href="#无参有返回" class="headerlink" title="无参有返回"></a>无参有返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; obj;<br></code></pre></td></tr></table></figure><h4 id="单参无返回"><a href="#单参无返回" class="headerlink" title="单参无返回"></a>单参无返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1) -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个时，可省略小括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1) -&gt; 一条语句<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个且 Lambda 体只有一条语句时，可省略小括号、大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 -&gt; 一条语句<br></code></pre></td></tr></table></figure><h4 id="单参有返回"><a href="#单参有返回" class="headerlink" title="单参有返回"></a>单参有返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1) -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个时，可省略小括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1) -&gt; 一条语句<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个且 Lambda 体只有一条语句时，可省略小括号、大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 -&gt; obj;<br></code></pre></td></tr></table></figure><h4 id="多参无返回"><a href="#多参无返回" class="headerlink" title="多参无返回"></a>多参无返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多参数指2个及以上的参数，这里使用两个参数说明</span><br><span class="hljs-comment">// ( Lambda 参数列表 ) -&gt; &#123; Lambda 体 &#125;</span><br>(param1, param2) -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1, param2) -&gt; 一条语句<br></code></pre></td></tr></table></figure><h4 id="多参有返回"><a href="#多参有返回" class="headerlink" title="多参有返回"></a>多参有返回</h4><ul><li>完整形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1, param2) -&gt; &#123; Lambda 体 &#125;<br></code></pre></td></tr></table></figure><ul><li>省略形式，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1, param2) -&gt; obj;<br></code></pre></td></tr></table></figure><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>基本语法测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaInterface</span> &#123;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无参无返回值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NoReturnNoParam</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个参数无返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NoReturnOneParam</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多参数无返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NoReturnMultiParam</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-comment">/*** 无参有返回*/</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnNoParam</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个参数有返回值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnOneParam</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多个参数有返回值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnMultiParam</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无参无返回-1"><a href="#无参无返回-1" class="headerlink" title="无参无返回"></a>无参无返回</h4><ul><li>完整形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnNoParam</span> <span class="hljs-variable">noReturnNoParam</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;NoReturnNoParam&quot;</span>);<br>&#125;;<br>noReturnNoParam.method();<br></code></pre></td></tr></table></figure><ul><li>省略形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnNoParam</span> <span class="hljs-variable">noReturnNoParam</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;NoReturnNoParam&quot;</span>);<br>noReturnNoParam.method();<br></code></pre></td></tr></table></figure><h4 id="无参有返回-1"><a href="#无参有返回-1" class="headerlink" title="无参有返回"></a>无参有返回</h4><ul><li>完整形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnNoParam</span> <span class="hljs-variable">returnNoParam</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> returnNoParam.method();<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res);<br></code></pre></td></tr></table></figure><ul><li>省略形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnNoParam</span> <span class="hljs-variable">returnNoParam</span> <span class="hljs-operator">=</span> () -&gt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> returnNoParam.method();<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res);<br></code></pre></td></tr></table></figure><h4 id="单参无返回-1"><a href="#单参无返回-1" class="headerlink" title="单参无返回"></a>单参无返回</h4><ul><li>完整形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnOneParam</span> <span class="hljs-variable">noReturnOneParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;NoReturnOneParam param:&quot;</span> + a);<br>&#125;;<br>noReturnOneParam.method(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个时，可省略小括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnOneParam</span> <span class="hljs-variable">noReturnOneParam</span> <span class="hljs-operator">=</span> a -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;NoReturnOneParam param:&quot;</span> + a);<br>&#125;;<br>noReturnOneParam.method(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnOneParam</span> <span class="hljs-variable">noReturnOneParam</span> <span class="hljs-operator">=</span><br>    (<span class="hljs-type">int</span> a) -&gt; System.out.println(<span class="hljs-string">&quot;NoReturnOneParam param:&quot;</span> + a);<br>noReturnOneParam.method(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个且 Lambda 体只有一条语句时，可省略小括号、大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnOneParam</span> <span class="hljs-variable">noReturnOneParam</span> <span class="hljs-operator">=</span><br>    a -&gt; System.out.println(<span class="hljs-string">&quot;NoReturnOneParam param:&quot;</span> + a);<br>noReturnOneParam.method(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><h4 id="单参有返回-1"><a href="#单参有返回-1" class="headerlink" title="单参有返回"></a>单参有返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnOneParam</span> <span class="hljs-variable">returnOneParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> returnOneParam.method(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res2);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个时，可省略小括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnOneParam</span> <span class="hljs-variable">returnOneParam</span> <span class="hljs-operator">=</span> a -&gt; &#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> returnOneParam.method(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res2);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnOneParam</span> <span class="hljs-variable">returnOneParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> returnOneParam.method(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res2);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 参数只有一个且 Lambda 体只有一条语句时，可省略小括号、大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnOneParam</span> <span class="hljs-variable">returnOneParam</span> <span class="hljs-operator">=</span> a -&gt; a;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> returnOneParam.method(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res2);<br></code></pre></td></tr></table></figure><h4 id="多参无返回-1"><a href="#多参无返回-1" class="headerlink" title="多参无返回"></a>多参无返回</h4><ul><li>完整写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnMultiParam</span> <span class="hljs-variable">noReturnMultiParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;NoReturnMultiParam param:&quot;</span> + <span class="hljs-string">&quot;&#123;&quot;</span> + a +<span class="hljs-string">&quot;,&quot;</span> + + b +<span class="hljs-string">&quot;&#125;&quot;</span>);<br>&#125;;<br>noReturnMultiParam.method(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><ul><li>省略写法，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NoReturnMultiParam</span> <span class="hljs-variable">noReturnMultiParam</span> <span class="hljs-operator">=</span> (a, b) -&gt;<br>    System.out.println(<span class="hljs-string">&quot;NoReturnMultiParam param:&quot;</span> + <span class="hljs-string">&quot;&#123;&quot;</span> + a + <span class="hljs-string">&quot;,&quot;</span> + +b + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>noReturnMultiParam.method(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><h4 id="多参有返回-1"><a href="#多参有返回-1" class="headerlink" title="多参有返回"></a>多参有返回</h4><ul><li>完整形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnMultiParam</span> <span class="hljs-variable">returnMultiParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">res3</span> <span class="hljs-operator">=</span> returnMultiParam.method(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res3);<br></code></pre></td></tr></table></figure><ul><li>省略形式，Lambda 体只有一条语句时，可省略大括号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReturnMultiParam</span> <span class="hljs-variable">returnMultiParam</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; a + b;<br><span class="hljs-type">int</span> <span class="hljs-variable">res3</span> <span class="hljs-operator">=</span> returnMultiParam.method(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<br>System.out.println(<span class="hljs-string">&quot;return:&quot;</span> + res3);<br></code></pre></td></tr></table></figure><h3 id="进阶用法-1"><a href="#进阶用法-1" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>Lambda 表达式的进阶用法需要结合方法引用实现，具体案例放到方法引用中。</p><blockquote><p>Note：<strong>以上这些规则都记不住也可以省略不记，可通过 idea 的 replaceLambda 表达式快速生成 lambda 表达式。</strong></p></blockquote><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用，一种更简洁地指向已有方法的 Lambda 表达式语法糖。</p><p>当 Lambda 表达式仅仅是调用一个已有方法时，使用方法引用可以使代码更清晰、更紧凑。</p><p>方法引用和 Lambda 表达式一样，也需要在函数式接口的上下文中使用，也就是说，方法引用必须与目标函数式接口的参数类型和返回类型兼容。</p><p>方法引用的四种类型：静态方法引用、特定对象的实例方法引用、任意类型对象的实例方法引用、构造方法引用。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>静态方法引用（Reference to a Static Method）：<strong>类名::静态方法名</strong></p><p>特定对象的实例方法引用（Reference to an Instance Method of a Particular Object）：<strong>对象::实例方法名</strong></p><p>任意类型对象的实例方法引用（Reference to an Instance Method of an Arbitrary Object）：<strong>类名::实例方法名</strong></p><p>构造方法引用（Reference to a Constructor）：<strong>类名::new</strong></p><p>注意事项：</p><ul><li>目标类型必须是函数式接口；</li><li>参数匹配规则：<ul><li>静态方法引用：函数式接口的参数作为静态方法的参数；</li><li>实例方法引用：函数式接口的第一个参数是调用方法的对象，其余参数是方法的参数（如 <code>String::equals</code> 对应 <code>(s1, s2) -&gt; s1.equals(s2)</code>）；</li></ul></li></ul><table><thead><tr><th align="left">场景</th><th align="left">Lambda 表达式</th><th align="left">方法引用</th></tr></thead><tbody><tr><td align="left">调用静态方法</td><td align="left"><code>x -&gt; Math.sqrt(x)</code></td><td align="left"><code>Math::sqrt</code></td></tr><tr><td align="left">调用已存在对象的实例方法</td><td align="left"><code>() -&gt; obj.getName()</code></td><td align="left"><code>obj::getName</code></td></tr><tr><td align="left">调用参数的实例方法</td><td align="left"><code>(a, b) -&gt; a.compareTo(b)</code></td><td align="left"><code>String::compareTo</code></td></tr><tr><td align="left">创建对象</td><td align="left"><code>() -&gt; new ArrayList&lt;&gt;()</code></td><td align="left"><code>ArrayList::new</code></td></tr></tbody></table><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>静态方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式</span><br>Function&lt;Integer, String&gt; lambda = num -&gt; String.valueOf(num);<br><br><span class="hljs-comment">// 静态方法引用</span><br>Function&lt;Integer, String&gt; staticRef = String::valueOf;<br><br>System.out.println(staticRef.apply(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 &quot;123&quot;</span><br></code></pre></td></tr></table></figure><ul><li>特定对象的实例方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-comment">// Lambda 表达式</span><br>Supplier&lt;String&gt; lambda = () -&gt; str.toUpperCase();<br><br><span class="hljs-comment">// 对象实例方法引用</span><br>Supplier&lt;String&gt; instanceRef = str::toUpperCase;<br><br>System.out.println(instanceRef.get()); <span class="hljs-comment">// 输出 &quot;HELLO&quot;</span><br></code></pre></td></tr></table></figure><ul><li>任意类型对象的实例方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式</span><br>BiFunction&lt;String, String, Boolean&gt; lambda = (s1, s2) -&gt; s1.equals(s2);<br><br><span class="hljs-comment">// 任意对象的实例方法引用</span><br>BiFunction&lt;String, String, Boolean&gt; arbitraryRef = String::equals;<br><br>System.out.println(arbitraryRef.apply(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>)); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure><ul><li>构造方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式</span><br>Supplier&lt;List&lt;String&gt;&gt; lambda = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 构造方法引用</span><br>Supplier&lt;List&lt;String&gt;&gt; constructorRef = ArrayList::<span class="hljs-keyword">new</span>;<br><br>List&lt;String&gt; list = constructorRef.get();<br>list.add(<span class="hljs-string">&quot;Data&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream 将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作。</p><p><img src="/Lambda-Expressions/image-20220321145135117.png" alt="image-20220321145135117"></p><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>Stream可以由数组或集合创建，对流的操作分为两种：</p><ul><li>中间操作，每次返回一个新的流，可以有多个；</li><li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用，终端操作会产生一个新的集合或值。</li></ul><p>Stream特性：</p><ul><li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</li><li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值；</li><li>stream 可启用并行流（底层使用 ForkJoinPool）加快处理速度；</li><li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ul><h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><table><thead><tr><th align="left">方法</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>集合.stream()</code></td><td align="left">集合创建顺序流</td><td align="left"><code>List&lt;String&gt; list.stream()</code></td></tr><tr><td align="left"><code>集合.parallelStream()</code></td><td align="left">集合创建并行流</td><td align="left"><code>list.parallelStream()</code></td></tr><tr><td align="left"><code>Arrays.stream(T[] array)</code></td><td align="left">从数组创建流</td><td align="left"><code>Arrays.stream(new int[]&#123;1, 2, 3&#125;)</code></td></tr><tr><td align="left"><code>Stream.of(T... values)</code></td><td align="left">直接传入元素</td><td align="left"><code>Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></td></tr><tr><td align="left"><code>Stream.iterate(种子, UnaryOperator)</code></td><td align="left">迭代生成流</td><td align="left"><code>Stream.iterate(0, n -&gt; n + 2)</code></td></tr><tr><td align="left"><code>Stream.generate(Supplier)</code></td><td align="left">无限生成流</td><td align="left"><code>Stream.generate(Math::random)</code></td></tr><tr><td align="left"><code>IntStream.range(start, end)</code></td><td align="left">生成整数范围流</td><td align="left"><code>IntStream.range(1, 5) // [1,2,3,4]</code></td></tr></tbody></table><p>Stream 常用创建方式有三种：</p><ul><li><p>通过 java.util.Collection.stream() 方法用集合创建流；</p></li><li><p>使用java.util.Arrays.stream(T[] array)方法用数组创建流；</p></li><li><p>使用Stream的静态方法：of()、iterate()、generate()。</p></li></ul><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><table><thead><tr><th align="left">方法</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>filter(Predicate&lt;T&gt;)</code></td><td align="left">过滤不符合条件的元素</td><td align="left"><code>.filter(s -&gt; s.length() &gt; 3)</code></td></tr><tr><td align="left"><code>map(Function&lt;T, R&gt;)</code></td><td align="left">元素一对一转换</td><td align="left"><code>.map(String::toUpperCase)</code></td></tr><tr><td align="left"><code>flatMap(Function&lt;T, Stream&lt;R&gt;&gt;)</code></td><td align="left">将元素映射为流并合并</td><td align="left"><code>.flatMap(list -&gt; list.stream())</code></td></tr><tr><td align="left"><code>distinct()</code></td><td align="left">去重（依赖 <code>equals()</code>）</td><td align="left"><code>.distinct()</code></td></tr><tr><td align="left"><code>sorted()</code></td><td align="left">自然排序</td><td align="left"><code>.sorted()</code></td></tr><tr><td align="left"><code>sorted(Comparator&lt;T&gt;)</code></td><td align="left">自定义排序</td><td align="left"><code>.sorted(Comparator.reverseOrder())</code></td></tr><tr><td align="left"><code>peek(Consumer&lt;T&gt;)</code></td><td align="left">查看元素（调试用）</td><td align="left"><code>.peek(System.out::println)</code></td></tr><tr><td align="left"><code>limit(long maxSize)</code></td><td align="left">限制元素数量</td><td align="left"><code>.limit(10)</code></td></tr><tr><td align="left"><code>skip(long n)</code></td><td align="left">跳过前 n 个元素</td><td align="left"><code>.skip(5)</code></td></tr></tbody></table><h4 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h4><table><thead><tr><th align="left">方法</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>forEach(Consumer&lt;T&gt;)</code></td><td align="left">遍历所有元素</td><td align="left"><code>.forEach(System.out::println)</code></td></tr><tr><td align="left"><code>toArray()</code></td><td align="left">转为数组</td><td align="left"><code>String[] arr = stream.toArray(String[]::new)</code></td></tr><tr><td align="left"><code>collect(Collector)</code></td><td align="left">转换为集合&#x2F;汇总结果</td><td align="left"><code>.collect(Collectors.toList())</code></td></tr><tr><td align="left"><code>reduce(BinaryOperator&lt;T&gt;)</code></td><td align="left">聚合元素（如求和）</td><td align="left"><code>.reduce((a, b) -&gt; a + b)</code></td></tr><tr><td align="left"><code>min(Comparator&lt;T&gt;)</code></td><td align="left">返回最小值</td><td align="left"><code>.min(Integer::compare)</code></td></tr><tr><td align="left"><code>max(Comparator&lt;T&gt;)</code></td><td align="left">返回最大值</td><td align="left"><code>.max(String::compareTo)</code></td></tr><tr><td align="left"><code>count()</code></td><td align="left">返回元素总数</td><td align="left"><code>.count()</code></td></tr><tr><td align="left"><code>anyMatch(Predicate&lt;T&gt;)</code></td><td align="left">任意元素匹配条件</td><td align="left"><code>.anyMatch(s -&gt; s.contains(&quot;a&quot;))</code></td></tr><tr><td align="left"><code>allMatch(Predicate&lt;T&gt;)</code></td><td align="left">所有元素匹配条件</td><td align="left"><code>.allMatch(n -&gt; n &gt; 0)</code></td></tr><tr><td align="left"><code>noneMatch(Predicate&lt;T&gt;)</code></td><td align="left">无元素匹配条件</td><td align="left"><code>.noneMatch(s -&gt; s.isEmpty())</code></td></tr><tr><td align="left"><code>findFirst()</code></td><td align="left">返回第一个元素</td><td align="left"><code>.findFirst()</code></td></tr><tr><td align="left"><code>findAny()</code></td><td align="left">返回任意元素（并行流高效）</td><td align="left"><code>.findAny()</code></td></tr></tbody></table><h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h4><ul><li><strong>集合创建顺序&#x2F;并行流</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Collection.stream() 方法用集合创建</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>);<br><span class="hljs-comment">// 创建一个顺序流</span><br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">// 创建一个并行流</span><br>Stream&lt;String&gt; stringStream = list.parallelStream();<br>List&lt;String&gt; collect = stringStream.collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li><strong>数组创建流</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Arrays.stream(T[] array) 方法用数组创建</span><br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream1</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br>System.out.println(stream1.max().getAsInt());<br></code></pre></td></tr></table></figure><ul><li>静态方法创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用Stream的静态方法：of()、iterate()、generate()</span><br>Stream&lt;Integer&gt; intStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">3</span>).limit(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 0 3 6 9</span><br>stream2.forEach(System.out::println);<br><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">10</span>);<br>Stream&lt;Integer&gt; stream3 = Stream.generate(()-&gt; m.getAndIncrement()).limit(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//10 11 12</span><br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h4 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map，可以将一个流的元素按照一定的映射规则映射到另一个流中；</p><p>map，接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter，对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中；</p><p>filter，按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>distinct，去除流中的重复元素；</p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted()，自然排序，流中元素需实现Comparable接口；</p><p>sorted(Comparator com)，Comparator排序器自定义排序。</p><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>limit，可以设置流的最大长度，超出的部分将被抛弃；</p><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p>skip，跳过流中的前n个元素，返回剩下的元素；</p><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>flatMap，接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流；</p><p>map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p><h4 id="终结操作-1"><a href="#终结操作-1" class="headerlink" title="终结操作"></a>终结操作</h4><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach方法，通过 lambda 表达式的方式遍历集合中的元素；</p><p>forEach，对流中的元素进行遍历操作，通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>count，用来获取当前流中元素的个数；</p><h5 id="max-min"><a href="#max-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h5><p>max&amp;min，可以用来或者流中的最值。</p><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p>collect，把当前流转换成一个集合；</p><p>collect，把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合；流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。</p><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>reduce，把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作；</p><p>reduce，对流中的数据按照你指定的计算方式计算出一个结果。</p><h3 id="进阶用法-2"><a href="#进阶用法-2" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>&#x2F;&#x2F;todo 省略，有空再补充</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/24/hello-world/"/>
    <url>/2025/06/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Clean-static-files"><a href="#Clean-static-files" class="headerlink" title="Clean static files"></a>Clean static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/commands#clean">Clean</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
